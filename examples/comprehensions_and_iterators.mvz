// MathViz Comprehensions and Iterator Methods Example
// Demonstrates list/set/dict comprehensions and functional-style iterator methods

// =============================================================================
// List Comprehensions
// =============================================================================

// Basic list comprehension - squares of numbers 0-9
let squares = [x^2 for x in 0..10]

// List comprehension with filter - even numbers only
let evens = [x for x in 0..20 if x % 2 == 0]

// Nested list comprehension - all coordinate pairs
let pairs = [(x, y) for x in 0..3 for y in 0..3]

// Matrix creation with nested comprehension
let matrix = [[i * j for j in 0..5] for i in 0..5]

// =============================================================================
// Set Comprehensions
// =============================================================================

// Unique remainders when dividing by 10
let remainders = {x % 10 for x in 0..100}

// Unique squares with filter
let small_squares = {x^2 for x in 0..20 if x^2 < 50}

// =============================================================================
// Dict Comprehensions
// =============================================================================

// Number to square mapping
let square_map = {x: x^2 for x in 0..10}

// Filtered dict comprehension
let even_squares = {x: x^2 for x in 0..10 if x % 2 == 0}

// =============================================================================
// Pipe Lambdas
// =============================================================================

// Simple single-parameter lambda
let double = |x| x * 2

// Multi-parameter lambda
let add = |a, b| a + b

// Lambda with more complex expression
let hypotenuse = |x, y| (x^2 + y^2)^0.5

// =============================================================================
// Iterator Methods - Transformation
// =============================================================================

let numbers = [1, 2, 3, 4, 5]

// map - apply function to each element
let doubled = numbers.map(|x| x * 2)

// filter - keep elements matching predicate
let big = numbers.filter(|x| x > 2)

// reduce - accumulate to single value
let total = numbers.reduce(0, |acc, x| acc + x)

// fold - alias for reduce
let product = numbers.fold(1, |acc, x| acc * x)

// =============================================================================
// Iterator Methods - Numeric
// =============================================================================

// sum - add all elements
let sum_result = numbers.sum()

// product - multiply all elements
let prod_result = numbers.product()

// min/max - find extremes
let minimum = numbers.min()
let maximum = numbers.max()

// average - compute mean
let mean = numbers.average()

// =============================================================================
// Iterator Methods - Access
// =============================================================================

// first/last - access ends
let head = numbers.first()
let tail = numbers.last()

// nth - access by index
let third = numbers.nth(2)

// find - first matching element
let first_big = numbers.find(|x| x > 3)

// position - index of first match
let pos = numbers.position(|x| x > 3)

// =============================================================================
// Iterator Methods - Predicates
// =============================================================================

// any - check if any match
let has_even = numbers.any(|x| x % 2 == 0)

// all - check if all match
let all_positive = numbers.all(|x| x > 0)

// count - number of elements
let length = numbers.count()

// =============================================================================
// Iterator Methods - Slicing
// =============================================================================

// take - first n elements
let first_three = numbers.take(3)

// skip - skip first n elements
let after_two = numbers.skip(2)

// take_while - take while predicate true
let until_big = numbers.take_while(|x| x < 4)

// skip_while - skip while predicate true
let after_small = numbers.skip_while(|x| x < 3)

// =============================================================================
// Iterator Methods - Ordering
// =============================================================================

let unsorted = [3, 1, 4, 1, 5, 9, 2, 6]

// sorted - sort ascending
let sorted_asc = unsorted.sorted()

// reversed - reverse order
let reversed_list = numbers.reversed()

// unique - remove duplicates preserving order
let unique_nums = unsorted.unique()

// =============================================================================
// Iterator Methods - Combination
// =============================================================================

let list1 = [1, 2, 3]
let list2 = ["a", "b", "c"]

// zip - combine two lists
let zipped = list1.zip(list2)

// enumerate - add indices
let indexed = list1.enumerate()

// chunk - split into groups
let chunked = [1, 2, 3, 4, 5, 6].chunk(2)

// =============================================================================
// Iterator Methods - Collection
// =============================================================================

// collect_set - convert to set
let as_set = unsorted.collect_set()

// join - combine strings
let words = ["hello", "world"]
let sentence = words.join(" ")

// group_by - group by key function
let grouped = [1, 2, 3, 4, 5, 6].group_by(|x| x % 2)

// partition - split by predicate
let partitioned = numbers.partition(|x| x % 2 == 0)

// =============================================================================
// Method Chaining
// =============================================================================

// Complex pipeline: filter, transform, collect
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(|x| x % 2 == 0)
    .map(|x| x * 3)
    .take(3)

// Another pipeline example
let processed = [5, 3, 8, 1, 9, 2, 7, 4, 6]
    .sorted()
    .skip(2)
    .take(5)
    .map(|x| x^2)
    .sum()

// Main function to demonstrate
fn main() {
    println("List Comprehensions:")
    println("  Squares: {}", squares)
    println("  Evens: {}", evens)
    println("  Pairs count: {}", pairs.count())

    println("\nIterator Methods:")
    println("  Doubled: {}", doubled)
    println("  Sum: {}", sum_result)
    println("  Mean: {}", mean)

    println("\nChained operations result: {}", result)
    println("Processed result: {}", processed)
}
